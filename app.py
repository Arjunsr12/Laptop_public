# -*- coding: utf-8 -*-
"""Laptop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HDOd6dR8WehIo6OfMlcI9kAhKOHss8V5
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

df=pd.read_csv("/content/drive/MyDrive/ADVERK /Datasets/laptop_data.csv")
df

df=df.iloc[:,1:]
df

df.info()

df.isnull().sum()

df['Ram']

df['Ram']=df['Ram'].apply(lambda x:x.replace("GB","")).astype('int')

print(df['Ram'])
df['Weight']=df['Weight'].apply(lambda x:x.replace("kg","")).astype("float")

df.info()

df.sample(5)

sns.displot(df['Price'])
plt.show()

df['Company'].value_counts().plot(kind='bar')

sns.barplot(x=df['Company'],y=df['Price'])
plt.xticks(rotation=90)
plt.show()

df['TypeName'].value_counts().plot(kind='bar')

sns.barplot(x=df['TypeName'],y=df['Price'])
plt.xticks(rotation=90)
plt.show()

df['Inches'].value_counts().plot(kind='bar')

sns.displot(df['Inches'])

sns.barplot(x=df['Inches'],y=df['Price'])

df['X_res']=df['ScreenResolution'].apply(lambda a:a.split()[-1].split('x')[0]).astype('int')
df['Y_res']=df['ScreenResolution'].apply(lambda a:a.split()[-1].split('x')[-1]).astype('int')

df.sample(5)

df['IPS']=df['ScreenResolution'].apply(lambda b:1 if "IPS" in b else 0)
df['Touchscreen']=df['ScreenResolution'].apply(lambda b:1 if "Touchscreen" in b else 0)

df.sample(5)

df.info()

df=df.drop(columns=['ScreenResolution'])

df.info()

df.corr(numeric_only=True)
#corr=corelation

df['PPI']=round(((df['X_res']**2)+(df['Y_res']**2)**0.5)/df['Inches'])

df.sample(5)

df.corr(numeric_only=True)['Price']

df=df.drop(columns=['X_res','Y_res','Inches'])

df.corr(numeric_only=True)['Price']

sns.displot(df['PPI'])
plt.show()

sns.scatterplot(x=df['PPI'],y=df['Price'])
plt.show()

df['IPS'].value_counts().plot(kind='pie')

sns.barplot(x=df["IPS"],y=df['Price'])

df['Touchscreen'].value_counts().plot(kind='pie')

sns.barplot(x=df['Touchscreen'],y=df['Price'])

sns.distplot(df['PPI'])

df['Cpu']=df['Cpu'].apply(lambda a:' '.join(a.split()[0:3]))

df['Cpu'].value_counts()

def fetch_processor(text):
  if text == 'Intel Core i7' or text == 'Intel Core i5' or text == 'Intel Core i3':
    return text
  elif text=='Intel Celeron Dual':
    return 'Intel Celeron Dual Core'
  else:
    if text.split()[0]=='Intel':
      return 'Other Intel Processor'
    else:
      return 'AMD Processor'

df['Cpu']=df['Cpu'].apply(fetch_processor)

df['Cpu'].value_counts()

df['Cpu'].value_counts().plot(kind='bar')

sns.barplot(x=df['Cpu'],y=df['Price'])
plt.xticks(rotation='vertical')
plt.show()

df.sample(5)

df.info()

df['Ram'].value_counts().plot(kind='bar')

df.info()

sns.barplot(x=df['Ram'],y=df['Price'])
plt.show()

df['Gpu'].value_counts()

a='Intel HD Graphics 620 '
a.split()

a.split()[0]

df['Gpu']=df['Gpu'].apply(lambda a:a.split()[0])

df=df[df['Gpu']!='ARM']

df['Gpu'].value_counts().plot(kind='bar')

sns.barplot(x=df['Gpu'],y=df['Price'])

df.info()

df['OpSys'].value_counts()

def opsys(text):
  if text=='Windows 10' or text=='Windows 7' or text=='Windows 10 S' or text=='Windows':
    return 'Windows'
  elif text=='macOS' or text=='Mac OS X' or text=='Mac OS':
    return 'Mac'
  elif text=='Linux':
    return 'Linux'
  else:
    return 'Chrome OS/Andriod/NoOS'

df['OpSys']=df['OpSys'].apply(opsys)

df['OpSys'].value_counts()

df['OpSys'].value_counts().plot(kind='bar')

sns.barplot(x=df['OpSys'],y=df['Price'])
plt.xticks(rotation='vertical')
plt.show()

df['Weight'].describe()

df.corr(numeric_only=True)['Price']

sns.displot(df['Weight'])

sns.scatterplot(x=df['Weight'],y=df['Price'])

df['Memory']

fdf=df.drop(columns=['Memory'],inplace=True)

df

sns.kdeplot(df['Price'])
#as this is not uniform ,we try taking the log of the prices

sns.kdeplot(np.log(df['Price']))
#in this we get a graph which is increased in the center

x=df.drop(columns=['Price'])
y=np.log(df['Price'])

from sklearn.model_selection import train_test_split

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.15,random_state=2)

x.shape

x_test.shape
#this is a random set of values
x_test

x_train.shape
#these are randomly choosen values
x_train

from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import r2_score,mean_squared_error,mean_absolute_error

from sklearn.linear_model import LinearRegression
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from xgboost import XGBRegressor

#Linear Regression
step1 = ColumnTransformer(transformers=[('col_tnf', OneHotEncoder(sparse_output=False, drop='first', handle_unknown='ignore'), [0, 1, 2, 4, 5])], remainder='passthrough')
step2 = LinearRegression()
pipe = Pipeline([('step1', step1), ('step2', step2)])
pipe.fit(x_train, y_train)
y_pred = pipe.predict(x_test)
print('R2 score', r2_score(y_test, y_pred))
print('MSE', mean_squared_error(y_test, y_pred))

#Ridge Regression
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2=Ridge(alpha=10)
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#Lasso Regression
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2=Lasso(alpha=0.001)
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#KNN Regression
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2=KNeighborsRegressor()
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#Regression trees
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2= DecisionTreeRegressor(max_depth=8)
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#Adaboost Regression
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2=AdaBoostRegressor(n_estimators=1000)
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#Gradient Regression
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2=GradientBoostingRegressor(n_estimators=500)
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#Extreme Gradient Regression
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2= XGBRegressor(n_estimators=10,max_depth=12,learning_rate=0.5)
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#Support Vector Machine Regressor
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2= SVR(C=100)
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))

#Random Forest Regression
step1=ColumnTransformer(transformers=[('col_tnf',OneHotEncoder(sparse_output=False,drop='first'),[0,1,2,4,5])],remainder='passthrough')
step2= RandomForestRegressor()
pipe=Pipeline([('step1',step1),('step2',step2)])
pipe.fit(x_train,y_train)
y_pred=pipe.predict(x_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))
print('MSE',mean_squared_error(y_test,y_pred))



import pickle
pickle.dump(df,open('df.pkl','wb'))
pickle.dump(pipe,open('pipe.pkl','wb'))

import streamlit as st
st.title("Laptop Price Predictor")
st.text("This app is designed to predict the laptop price based on the configuration")
st.text("Once the configuration details of the laptop are entered,")
st.text("please click on the PREDICT button to get the estimated price of the laptop")
 
import pickle
import numpy as np
pipe=pickle.load(open('pipe.pkl','rb'))
df=pickle.load(open('df.pkl','rb'))

company=st.selectbox("Brand",df['Company'].unique(),index=4)
type1=st.selectbox("Type",df['TypeName'].unique(),index=1)
cpu=st.selectbox("Processor",df['Cpu'].unique(),index=0)
ram=st.selectbox("RAM(in GB)",[2,4,6,8,12,16,24,32,64,128],index=3)
gpu=st.selectbox('Graphics Card',df['Gpu'].unique(),index=0)
os=st.selectbox('Operating System',df['OpSys'].unique(),index=2)
weight=st.slider('Weight(in kg)',min_value=0,max_value=4,value=2)
ips=st.selectbox('IPS Display?',['No','Yes'])
touchscreen=st.selectbox('Touchscreen?',['No','Yes'])
screen_size=st.number_input("Size of the screen(In Inches, measured diagonally)",
min_value=10,max_value=18,value=15)
resolution=st.selectbox("Screen Resolution",['1920x1080','3840x2160','3200x1800',
'2560x1600','2880x1800','1366x768','2304x1440','1440x900','2560x1440','1600x900',
'2256x1504','2400x1600'],index=0)
 
if st.button("PREDICT PRICE"):
  ppi=None
if touchscreen =='Yes':
  touchscreen=1
else:
  touchscreen=0
if ips == 'Yes':
   ips=1
else:
   ips=0
X_res=int(resolution.split('x')[0])
Y_res=int(resolution.split('x')[1])
 
ppi =((X_res**2)+(Y_res**2))**0.5/screen_size
 
query=np.array([[company,type1,cpu,ram,gpu,os,weight,ips,touchscreen,ppi]])
op=np.exp(pipe.predict(query))
st.subheader("The predicted price for the laptop with above mentioned configuration is:")
st.subheader("Rs."+str(round(op[0])))

